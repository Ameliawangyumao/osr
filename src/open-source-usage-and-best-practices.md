# 开源使用规范及业界优秀实践

## 总纲

开源使用规范是依托于可信的开源软件供应链的思想，对开源软件进行端到端的流程管理。上一节讲到的网络安全风险、法规风险、生命周期的风险，流程主要包含供应、使用及维护，往细了说就是选、用、维、馈。

## 开源使用规范

### 导读

* 为确保满足网络安全、合法合规、可追溯性要求，从研发角度规范产品/平台开发团队对开源软件代码合理使用，特制定本规范，指导产品正确使用开源软件，满足以下目标要求： 
  * 无开源代码片段引用问题
  * 无GPL感染被动开源情况
  * 无类似开源确认为自研情况，开源使用声明及履行对外开源义务合规，无法务风险
  * 满足开源软件网络安全管理要求
* 当前企业使用开源主要有两种场景：二次开发（编译器、内核）和调用（命令行、动静态库）。第一种场景有能力做代码修改实现差异化竞争力；第二种场景以不修改为主，但是实际过程中也产生代码修改。两种场景都存在“版本老旧、片段引用、开源自研代码混淆”等现状以及由此带来的“网络安全、合法合规、可追溯性差”等问题。本实践从软件开发-维护不同阶段对使用规范进行约束，并提出规则、建议、标准和对工具的要求。

| 类别       |   选型   | 集成     | 架构与设计                                                 | 开发                             | 维护                           |
| ---------- | :------: | :------- | ---------------------------------------------------------- | -------------------------------- | ------------------------------ |
| 现象       | 版本老旧 | 协议遵从 | 没有充分利用扩展机制                                       | 片段引用、对开源原生代码进行修改 | 社区安全补丁缺乏跟踪；版本老旧 |
| 带来的问题 | 网络安全 | 合法合规 | （对开源原生代码不必要的修改所带来的）网络安全、可追溯性差 | 网络安全、合法合规、可追溯性差   | 网络安全                       |
| 业界案例   |   SUSE   | Google   |                                                            | IBM/Google/微软                  | Red Hat                        |

### 总体规则概览

| 阶段                                                         |                           优秀实践                           |
| ------------------------------------------------------------ | :----------------------------------------------------------: |
| 选型                                                         | 1.1 面向个人或家庭消费者用户的产品，禁止使用GPL V3高风险开源软件，其他产品需经风险评估后方可使用，同时在采购或合作界面应限制供应商或合作方引入 |
| 选型                                                         |        1.2 开源软件选型必须通过开源软件的基础安全评估         |
| 集成                                                         |     2.1 产品/平台集成开源软件的方式须满足开源license要求      |
| 架构设计解耦                                                 |                      3.1 自研与开源解耦                       |
| 架构设计解耦                                                 |  3.2 分析开源软件扩展机制，优先使用内置扩展机制实现定制特性   |
| 架构设计解耦                                                 |      3.3 遵从社区版本开发原则，对开源的修改尽量回馈社区       |
| 代码修改                                                     |                 4.1 禁止片段引用开源软件代码                  |
| 代码修改                                                     |     4.2 未经评审不得随意修改开源原生代码，开源定制最小化      |
| 代码修改                                                     | 4.3 涉及源代码交付，对开源原生代码进行修改的代码，使用Patch方式管理 |
| 代码隔离与目录管理                                           |           5.1 开源软件与自研代码独立存放，目录隔离            |
| 代码隔离与目录管理                                           |               5.2 开源修改的patch独立存放可管理               |
| 代码隔离与目录管理                                           |         5.3 整包使用开源软件，版本名称与官网保持一致          |
| 履行开源义务                                                 |                6.1 开源使用声明无遗漏、易获取                 |
| 履行开源义务                                                 |                   6.2 履行代码对外开源义务                    |
| 履行开源义务                                                 |    6.3 如对开源软件修改，须在修改的源码文件头附上修改声明     |
| 开源与自研判定原则                                           | 7.1 基于事实确认，根据代码实际来源进行确认，不得将开源代码确认为自研 |
| 维护与升级替换                                               |          8.1 产品使用开源软件须具备开源软件维护能力           |

### 开源选型的详细检查项

选型须选择优选高价值的开源软件，避免选择以下情况软件：
* 产品规格与OSS开源版本不匹配，如导致修改代码超过20%，则不如“自研或购买” 
* OSS License不兼容产品策略
* OSS质量(安全)不足以支撑目标产品
* OSS社区是垂死或项目已废弃

| 阶段       |              检查项（14条）               |
| ---------- | :---------------------------------------: |
| 1 技术生态 |           1.1 技术架构与技术规划           |
| 1 技术生态 |      1.2 主流的供应商/社区或社区项目       |
| 1 技术生态 | 1.3 业界成熟应用情况或我司产品实际使用效果 |
| 2 合法合规 |              2.1 获取来源可靠              |
| 2 合法合规 |            2.2 许可证、知识产权            |
| 2 合法合规 |          2.3 贸易合规/业务连续性           |
| 3 生命周期 |               3.1 软件生命力               |
| 3 生命周期 |              3.2 社区支撑能力              |
| 4 生命周期 |                4.1 病毒扫描                |
| 4 生命周期 |        4.2 通过漏洞扫描发现安全风险        |
| 4 生命周期 |              4.3 已知安全问题              |
| 4 生命周期 |              4.4 后期安全维护              |
| 4 生命周期 |   4.5 安全红线测试（A类除日志相关要求）    |

### 开源选型规则（法务/安全）

#### 1.1  规则 面向个人或家庭消费者用户的产品，禁止使用GPL V3类高风险开源软件，其他产品需经风险评估后方可使用，同时在采购或合作界面应限制供应商或合作方引入
* 检验标准：个人或家庭消费者用户的产品在引入三方库的阶段进行许可证校验，禁选GPL V3协议。TR5/TR6检查产品及供应商软件无GPL V3高风险开源软件和禁选软件。

| 流程环节                                               |                           管控策略                           |
| ------------------------------------------------------ | :----------------------------------------------------------: |
| 准入与优选等级：采购流程                               | 在采购协议模板中增加条款，禁止或限制供应商引入使用GPL V3类软件 |
| 准入与优选等级：入库流程                               | 在入库流程PDU预审环节中增加GPL V3类自检check项，提前知会产品风险，若产品要引入GPL V3类软件，但无法满足V3要求，则建议不予引入。 |
| 准入与优选等级：优选等级                               | GPL V3类软件优选等级最高为可选，对于风险最高的终端手机、终端芯片、终端MBB产品线则禁选。 |
| 使用申请流程                                           | 产品申请的GPL V3类软件（包括继承申请），必须结合使用场景分析license风险，根据风险等级在相应业务层级决策后使用；使用申请电子流中，GPL V3类软件IPR评审环节一律由律师人工审核，未经风险分析及业务决策则禁止申请使用。 |

#### 1.2  规则 开源软件选型必须通过开源软件的基础安全评估
* 规则描述：开展开源软件选型评估活动时，未依据开源软件网络安全选型评估方法开展基础安全评估的开源软件不能通过选型。具体参见开源软件网络安全管理要求中的选型要求。
* 检验标准：同规则描述
* 网络安全：
  * 病毒扫描
  * 通过漏洞扫描发现安全风险
  * 已知安全问题：社区是否有高危漏洞没有修复（NVD)
  * 后期安全维护：社区是否有安全维护机制和良好修复记录

### 集成关注传染性，避免核心代码被动开源

#### 2.1  规则 产品/平台集成开源软件的方式须满足开源license要求
* 规则描述：将开源软件引入到产品/平台中，必须遵从license约定进行集成，具体要求参见如下表格“开源License约束及其要求”。<br>对于开源软件含有双License或者多License的情况下，产品/平台需要根据license的约定及实际使用场景确定属于哪个License，如果没有特殊声明或限制，建议选择相对宽松和商业友好的License，如仍有异议，可咨询接口对应产品线的律师代表。
* 过程要求：研发阶段选型及架构设计时明确集成方式（进程调用、静态链接、动态链接等），确保开源使用申请电子流中“Application Mode/使用方式”字段信息准确，开发人员严格按照此方式集成使用，SE在系统设计实现评估时完成审核及验收。（评估手段举例：可跟踪编译构建脚本的变动）
* 检验标准：同规则描述

| 常见许可证类型         |       典型软件        | 触发代码开源义务前提条件                                     | 开源要求和范围                                               | 规避开源方式                                                 |
| ---------------------- | :-------------------: | :----------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| BSD类 如Apache/BSD/MIT |    Tomcat,OpenSSL     | 无                                                           | 无                                                           | 不涉及                                                       |
| MPL类 如：MPL/EPL等    |    FireFox,Eclipse    | 产品集成使用该软件，并对外分发或销售，产品对该软件进行了修改 | 若无修改，则无需开源；若对其进行了修改，需将修改的部分开源   | 使用时不做任何修改                                           |
| LGPL                   |   Hibernate，glibc    | 产品集成使用该软件，并对外分发或销售                         | 软件本身须开源。具有传染性，与其静态链接部分的代码也必须以LGPL许可开源；动态链接则不被传染 | 动态链接使用，仅开源其软件本身即可，产品代码可免受传染     |
| GPL                    | Busybox，linux kernel | 产品集成使用该软件，并对外分发或销售                         | 软件本身须开源。具有传染性，与其有链接关系的代码都必须以GPL许可对外开源，即与该软件在同一进程中运行的代码都必须开源 | 进程隔离，独立于产品进程运行，仅开源其软件本身即可，产品代码可免受传染 |
| AGPL                   |      Berkeley DB      | 产品集成使用该软件                                           | 同GPL                                                        | 同GPL                                                        |
| SSPL                   |        mongodb        | 产品集成使用该软件                                           | 同GPL + 其他相关运行服务                                     | 仅内部使用、不对外；购买商业协议                             |

### 架构设计解耦规则

#### 3.1  规则 自研与开源解耦
  * 规则描述：自研和开源代码解耦，逻辑解耦（可以独立升级开源软件版本）、物理解耦（独立文件存放）
  * 问题案例：自研和开源代码相互融合，难以解耦，同步社区漏洞或升级困难
  * 处理策略：制定基于开源开发的分层插件式的解耦策略，下列解耦的方式供参考：
    * 特性间解耦：机制和策略分离、数据面和控制面分离
    * 独立组件程序 
    * 动态库链接方式 调用
    * 静态库链接方式 调用 
    * 形成独立的文件
  * 某产品整改过程中架构解耦的实践
    * 如果可以解耦调用，那么解耦 —— A包含了B的代码变成A引用B的代码（案例: kernel模块）。这种情况下，需要引入B项目，需要额外申请B软件的使用说明并对外履行义务
    * 如果解不开，而且的确是基于开源做的大量修改，那么老老实实认定这个项目是“对开源软件的修改”，而不是“自研软件对开源软件的引用”。—— A包含了B的代码变成A就是B。这种情况下，补丁式处理这种修改结果并且牵引更加合理的修改
    * 转自研

#### 3.2  建议 分析开源软件扩展机制，优先使用内置扩展机制实现定制特性
  * 案例：分析Linux内置扩展点，优先使用内置扩展点实现最佳解耦。

#### 3.3  建议 遵从社区版本开发原则，对开源的修改尽量回馈社区  
  * 不背离社区，明确架构原则，遵从社区开发原则，对开源原生代码修改尽量回馈社区，不破坏开放和生态基础，避免与社区API接口不一致问题。
  * 基于开源开发新特性或功能时，产品需审视并遵从开源社区架构/设计的匹配情况，可参考以下流程决定哪些新增/修改代码应该开源或私有或废弃。
  * 基于开源开发新特性/功能流程：
    * 首先要把私有代码和被感染的代码进行相应的分析。私有代码里，要保证私有代码不会再混入一些其它的开源代码，如果说ok，那么相应的片段，按照上面相应几种处理策略进行改造，改造后再纳入到开源软件流程。如果私有代码里不再包含有代码片段，可以把它放到自研代码库里；
    * 开源软件代码，要按照不同的license用不同的策略分，如果License要求注明相应的分发，要去分发我的license，管理员注明完成之后，仅到此为止，就要在产品的痤件中增加相应的开源软件声明，声明里要包含版权人的信息、License，这是履行义务。还有一种可能就是像GPL，就需要把代理开源出去，这就不仅仅只是附上声明，还要有相应的代码，打包回馈给社区或者是自己建立一个外部的仓库开源。

### 自研项目严禁片段引用

#### 4.1  规则 禁止将开源软件部分函数/宏或部分文件拷贝到产品自研代码中使用
* 片段引用：未完全引入开源软件版本的整包代码，仅将部分函数/宏或部分文件拷贝到产品自研代码中使用。
* 违反原则带来的风险：
  * 所有权问题：自研意味着Copyright都是华为，片段使用会导致自研代码混淆了非华为版权的代码。对于本身就是开源的项目，片段使用不存在这个问题；    
  * 协议履行问题：开源协议会涉及义务履行，片段使用容易导致“不知道使用了什么协议的代码”，进而忘了对外义务履行；
  * 安全追溯问题：如果社区项目有修复更新，片段使用的代码不容易追溯社区的修复。
* 片段引用情况举例：
  * 函数名不同，函数体相同（仅函数名不同，基本功能算法代码片段与开源完全相同） ；
  * 整段宏定义与开源代码完全相同；
  * FOSSID相似度不高，但除函数内调用的接口不同外，变量定义等都与开源代码完全相同。
* 整改处理策略：
  * 不允许片段引用，对于片段引用需整改，可自研重写，或采取申请整包使用、部分编译的方法，或其他软件替代方案。对于部分文件引入，也采用整包使用、部分编译的方法。
  * 自研重写：
    * 如果做不到整包使用，也没有可替代的软件，则自研重写；
    * 判断产品代码是否使用了开源软件，不仅仅是完整地使用该开源软件提供的所有交付件，还包括使用其代码片段，即在产品代码中如果使用了开源软件典型的代码片段，也会被认为用了该开源软件，所以在重写时尽量不要参照其代码，否则可能会被检测出重写的代码也使用了该开源软件。
* 检验标准：对产品全量代码进行分析，确保所有使用的开源软件是整包使用，无片段引用情况，可借助FOSSID扫描工具辅助分析。
* 错误的整改 -- 高危！！！
  * 修改函数名、调整上下顺序

### 开源私有修改不可避免 VS 严重债务 + 不合理修改

* 案例1：硬件方案差异导致的修改开源原生代码
  * 开源代码：UEFI(Unified Extensible Firmware Interface)，一种BIOS框架，用于引导OS启动。
  * 修改原因：因硬件方案差异(PC不需要清狗，服务器使用BMC方案，华为使用CPU清狗)，需要在开源代码中增加清狗实现，不修改会导致启动过程因狗咬死复位。
* 案例2：网络硬件的可靠性要求导致的修改开源原生代码
  * 开源的ahci驱动框架，在复位流程上不满足网络硬件方案的可靠性要求，需要在此处增加对端口的复位操作，解决sata硬盘概率性挂死的可靠性问题。
* 案例3：开源代码入参校验导致修改开源原生代码
  * 开源代码：UEFI(Unified Extensible Firmware Interface)，一种BIOS框架，用于引导OS启动。
  * 修改原因：修改部分的开源代码被工具扫描出fortify告警和安全风险。
* 业内情况：《开源使用规范》word版本用的红帽GDM案例也表明此情况在业内也是一个常见的做法。但业界涉及此情况，优先合入社区，社区不接纳才保留少部分的这些修改的私有化patch。

### 未经评审不得随意修改开源原生代码

#### 4.2  规则 未经评审不得随意修改开源原生代码
* 规则描述：对于基于开源的定制应尽量少，严格控制对开源原生代码内部进行修改，优先使用回调/适配等技术解耦方案而不修改开源软件原生代码方式。但如涉及修改开源原生代码，须经过评审（开源软件代码修改策略必须经过产品/平台各自的TRB或CCB评审通过；修改的代码由各开源软件模块维护方负责评审把关），技术上合理才允许修改，同时对于修改的代码尽量回馈社区。
* 但如涉及对开源原生代码进行修改，存在华为开源修改patch，可参考如下两条建议执行：
  * 建议1：不更改开源原生数据结构，保持兼容性
    * 案例：变更（新增、修改、删除）开源结构体，影响KABI（Linux内核态应用接口）兼容性。但实际确实会遇到不得不对原生数据结构修改诉求，对此如何处理？
      处理策略：尽量不修改开源原生数据结构，一定不要删除开源社区数据结构，如必须修改，则建议通过面向对象的方式派生出一个子对象，定义自己成员；或通过封装或扩展一个新数据结构体供自己使用。
  * 建议2：尽量封装成函数或宏方式，提高扩展性
    * 案例：kernel/fork.c中有代码初始化，重构前在函数中对结构体成员赋值，可扩展性比较低。
* 规则目的：提高维护升级效率的方法
  * 解耦 – 降低维护难度
  * 控制修改 – 降低维护数量

### 涉及源代码交付，对开源原生代码进行修改的代码，使用Patch方式管理 

#### 4.3  规则 涉及源代码交付，对开源原生代码进行修改的代码，使用Patch方式管理
* 规则描述：源代码交付场景，如涉及对开源原生代码进行修改，则修改的代码形成Patch文件并对其进行管理。
  注：对开源原生代码进行修改形成Patch文件，只是一种管理形式，并不解决耦合问题，实际上这种修改方式仍是将修改的代码与开源代码耦合在一起，模糊不清。
* 建议：对开源修改的代码形成Patch文件，并对开源修改Patch进行管理；每次贡献/合入社区的Patch尽量只解决一个问题，功能单一，通过Patch化合入每次修改的内容。修改开源的Patch源码文件，采用开源社区代码规范要求，方便回归社区。

### 开源代码隔离和目录存放规则

#### 5.1  规则 开源及开源软件与自研代码独立存放，目录隔离
  * 规则描述：将产品自研代码与开源软件隔离(参见业界Google案例)，开源软件独立目录存放。从代码目录结构区分出open_source目录、 vendor目录、code自研目录。
  * 检验标准：同规则描述
  * Google开源软件管理：https://opensource.google.com/docs/thirdparty/

#### 5.2  规则 开源修改的patch独立存放可管理
  Q：社区修改，未形成patch，仅有commit，算不算社区补丁？                 
  A：算                                
  Q：社区CVE代码有没有命名标准？                               
  A：建议 name-version-CVEnum    openssl-1.1.1-CVE-XXXX.patch         
  Q：开源项目社区名要求是什么？                   
  A：有中心仓场景沿用中心仓目录名（大小写等），无中心仓场景沿用PDM名                       

#### 5.3  规则 整包使用开源软件，版本名称与官网保持一致（该规则确保可追溯可管理）
* 以openssh为例，RedHat的版本名称为openssh-7.4p1-13-el7_4，取RedHat的，则要与RedHat的版本名称一致，命名为openssh-7.4p1-13-el7_4；openssl社区版本名为openssl 1.0.2h，若从openssl社区取的源码，则名称为openssl 1.0.2h。
* 检验标准：代码库中集成的开源软件名称与申请时官网名称一致，确保版本和社区来源版本一致。

### 开源软件义务履行规则

#### 6.1  规则 开源使用声明无遗漏、易获取
  * 规则描述：产品发布时，随产品附上一份文档《Open Source Software Notice》，在该文档中写明产品所使用的开源软件及其版权和license信息，并附上我司的不担保声明。同时确保使用声明软件与实际使用的软件保持一致，避免遗漏，易获取。
  * 根据产品中所使用的开源软件，按以下格式输出软件声明（Copyright Notice and License Texts）
    * Software: 软件名称+软件版本号
    * Copyright notice: 软件版权信息 (软件包中版权或说明文件/官网/代码文件头)
    * License: 软件License信息（包含具体内容）
  * 检验标准：设计师组织审核验证《Open Source Software Notice》文档，确保其符合开源使用声明义务履行要求。

#### 6.2  规则 履行代码对外开源义务
  * 规则描述：对于涉及敏感国家地区销售的产品，若产品涉及履行对外开源义务，须组织审核验证“对外开源代码包”，根据团队所选择的对外开源方式（如written offer）履行义务，确保无法务风险。
    * 产品应结合自身使用场景，按照所使用的开源软件License要求将相应代码从产品代码中提取出来制作开源代码包；
    * 开源内容必须为代码，若产品是以二进制包形式使用开源软件，也必须提供其源码；
    * 开源内容不得超出license要求范围，且开源内容范围必须通过审批决策；
    * 对于GPL/LGPL类开源软件，必须确保开源代码能够通过编译：
      * 书面邀约（Written Offer）：若产品使用了GPL、LGPL、MPL等具有对外开源义务的软件，必须在使用声明中附上此部分(除非产品线选择直接对外提供应开源的源代码)，向客户承诺履行代码开源义务。此部分直接从模板中拷贝使用；若产品不涉及强制开源义务，则使用声明文档中不得包含此部分内容；
      * AGPL V3开源件被用于远程交互场景下时，修改代码后即使不分发也必须向用户提供源代码。不能采用统一的written offer模式，对使用AGPL V3的在线软件的开源遵从方式需改成直接开源。

#### 6.3  建议 如对开源软件修改，须在修改的源码文件头附上修改声明
  * 规则描述：指产品若对开源软件进行了修改，须在修改的源码文件头附上修改声明，说明修改人、修改时间、修改内容。

### 开源自研判定规则

#### 7.1  规则 基于事实确认，根据代码实际来源进行确认，不得将开源代码确认为自研
* 规则描述：没看过开源代码的人写出来的东西叫自研，其他任何形式参考开源搞的代码都算开源。不允许将开源确认为自研。
  如确认错误，误将开源确认为自研或采购件的话，会带来法务纠纷或诉讼。华为自研开放到开源社区的源代码，属于开源社区，应视为开源软件对待。
* 检验标准：无开源确认为自研情况。
* 案例1：匹配上孤立的代码，此类可不确认为开源软件。例如：
     * 头文件引入（include xxxxx）
     * 控制语句（if then。。。）
     * 变量定义、数组定义、参数定义、宏定义等
* 案例2：匹配上常见的冒泡排序等此类常用算法可不确认为开源软件。

### 开源自研判定规则进阶

* 法理依据
  * 思想与表达 – 思想没有版权、表达有版权。软件的功能是思想，功能的实现是表达；
  * 如果一个思想仅有少数的表达，那么表达的相似不做追究。
* 开源转自研的难度
  * 思想同开源项目 --- 框架类似开源项目 --- 结构体类似开源项目 --- 流程类似开源项目 --- 代码类似开源项目
* 开源自研的攻防
  矛：如何肉眼预估存在片段引用 
  如果结构体和流程相似，代码大概率类似开源项目。
  盾：如何自证清白
  避免陷入代码相似的争论，从源头上自证 – 功能（思想）存在差异不同，设计文档存在差异。
* 案例：企业开源的项目能否认定为自研
  * 某团队将代码开源出去，同时在另外一个自研项目里面片段复用了同样的代码，那么是否还需要整改？如果不整改，便违背了开源自研隔离的要求；如果整改，自己写的代码为什么开源后就失去了控制权，还要想另一个方法再实现一遍？
  * 解答：这问题主要出在“自研和开源”的提法上，这个提法事实上形成了“对立”：即非自研就是开源。它在绝大多数情况下是正确的，沿用利于团队实施。但从字眼上分析，“自研”的对立面是“第三方”，“开源”的对立面是“闭源”。回到上面的案例，这段代码即属于“自研”，也属于“开源”，而且当自研认定符合本文开头的三个原则时，则不需要整改。
* 所有权和开源协议
  * 所有权是企业的代码，协议解释权也属于企业 —— 可以把这段代码规定为各种开源协议，也可以规定为商业协议（参考Oracle/Mongodb的双协议案例）。企业代码被开源“污染”属于法务遵从的问题，不破坏所有权。
  * 例如，企业A项目和社区GPL协议的B项目静态链接生成C产品，那么A项目在C产品的场景下，需要遵循GPL的协议对外履行义务；
    之后（不包括B)，如果A项目和企业内部的自研D项目静态链接生成E产品，那么A项目在E产品的场景下，完全可以以企业自研进行认定，不会因为“曾经被B污染”而导致在E场景下也是GPL协议，更不会进一步导致D项目也变成GPL。    

### 维护与升级替换规则

#### 8.1  建议 产品使用开源软件须具备开源软件维护能力
  * 产品使用开源须具备开源维护能力。对于产品核心模块使用开源(Baby级开源软件)情况，建议参与并主导开源社区，具备社区影响力，掌握此开源软件的演进方向和发展趋势，具备开源软件维护能力，满足客户问题响应和安全漏洞修复SLA要求。参考样例，如下不同BCT等级开源软件维护阶段要求如下：

| 使用场景     |                           质量策略                           | 质量活动：选型                                               | 质量活动：开发                                               | 质量活动：测试                                               | 质量活动：维护                                               |
| ------------ | :----------------------------------------------------------: | :----------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Teddy Bear级 | 满足产品基本质量要求，使用稳定可靠版本，关注License，基本功能需求实现，以及已知漏洞的解决 | 按公司要求基本评估，明确使用价值，重点关注License风险，网络安全风险，功能满足度分析 | 开发人员集成开源软件，进行功能验证，确保开源软件能够实现产品功能 | 1、通过黑盒测试（SDV/SIT/SVT）对产品需求规格测试间接覆盖该级别开源软件 2、继承使用的开源软件要做相关特性的基本功能验证；升级使用的开源软件要做相关特性的全面验证 | 1、社区已知漏洞的同步解决 2、持续审视升级至稳定可靠的版本    |
| Cat级        | 基于Teddy Bear级要求之上，增加对软件接口、参数，甚至技术架构的理解，具备一定修改和自维护能力，参与社区，能够回合修改的代码 | 1、需要至少是设计师才能分析引入，不能仅仅开发人员分析就把Cat级开源软件引入到产品中；2、重点参考软件质量属性（功能满足度、技术架构、竞争力、易用性、可靠性、可维护性、性能等） | 1、针对代码修改进行测试设计：修改和新增代码测试要求等同于自研 2、针对开源软件的接口和参数进行测试设计，使用的产品要保证用到的接口和参数组合是能满足产品功能要求的 | 1、针对开源实现的功能特性来做测试设计；2、继承使用的开源软件要做相关特性的基本功能验证；升级使用的开源软件要做相关特性的全面验证 | 除完成Teddy Bear级要求的已知缺陷、漏洞跟踪和选用优选版本外，重点是对开源软件使用后修改负债风险识别和管理 |
| Baby级       | 基于Teddy Bear级要求之上，对开源软件架构和代码有较深的理解，与社区保持互动，持续维护社区关系，建立社区影响力，具备社区同步能力，以及代码级的测试和维护能力 | 1、需技术开发项目中或产品开发项目的TR2前经过全面备选分析后多方面权衡确定；除满足公司开源软件选型的相关要求外，还要从软件质量和软件社区两方面多维度综合衡量；2、开源社区发展方向、开放性、活跃度、生态维度全面分析 | 1、复制社区的质量防护网：要引入社区的代码质量保证措施，如代码Review和扫描工具、测试用例、性能测试工具等；2、修改代码需满足华为的自研代码质量要求，代码规范类除外 | 针对开源实现的功能特性来做测试设计，同时补充稳定性和可靠性等DFX方面的测试用例，保证开源实现特性达到可靠的商用标准 | 1、熟悉开源软件的架构和流程，具备代码级维护能力，能够定位和解决问题 ；2、参与并影响社区，减少非竞争力私有化代码 |

## 开源软件维护

### 开源软件维护总体原则

* 对于社区已经披露漏洞，但未提供漏洞修补方案的，由产品自行消减漏洞风险；
* 开源软件维护方发布新版本或社区补丁的质量标准同社区发布标准，回合补丁须保证漏洞已被修补；
* 开源软件维护方发布新版本或补丁修补漏洞应满足开源软件漏洞修补SLO时间；
* 开源软件维护方不仅要对主软件（及下层开源组件）进行维护，也须对依赖软件（及下层开源组件）进行维护；
* 开源软件维护方不承接产品特性或功能需求，若产品有相关需求，则通过正常平台需求管道提出。

### 漏洞修复流程

我们没有专业的人和工具去获取漏洞信息，会有相应的漏洞库，定期推送漏洞信息，有psirit专家团队，定期分析这些漏洞并修复。系统会将漏洞推送给所有使用典型商业软件的产品团队，产品团队进一步分析，是否影响产品，如果影响，就会推送给维护方。维护方可能是专业的的开源软件专家，进一步调整解决方案；解决方案有可能来自社区，社区有解决方案，我们是要用社区解决方案还是企业自己的解决方案？社区版本可以自己维护控制，一旦产品团队自己过多的维护干扰，后面的代码升级有可能出现漏洞。所以，尽可能用社区的解决方案，保障代码的升级。如果社区没有解决方案，我们在SLA的使用范围内，产品团队可以做一些修复，消解风险后，可以通知市场销售团队，哪些产品在哪些国家哪些客户产生了影响，提供修复的方案给市场销售团队，和客户一起修复漏洞。

### 整体要求

* 规则1：开源软件维护方感知开源软件漏洞后，应在社区补丁/新版本发布的24小时内，将补丁信息或者新版本信息发布到ICE，并同步到漏洞库，以起算产品版本漏洞修补SLO。
  说明：开源软件维护方从PSIRT获取漏洞信息后，要保证及时感知补丁，社区发布补丁后，开源软件维护方须在24小时内反馈有补丁或新版本信息到公司ICE，并同步到漏洞库，以支撑产品版本确定漏洞修补SLO的起算点。开源软件维护方要持续与社区互动，监控社区补丁的ready情况，并将补丁或新版本信息（包括但不限于名称/版本/URL地址/发布时间等）刷新到ICE。如果社区补丁发布时间比PSIRT漏洞通知早，以收到PSIRT漏洞通知时间起算。
* 规则2：以社区披露漏洞的受影响版本为准，开源软件维护方要分析开源软件新版本中存在的漏洞是否在维护的版本中也同时存在，如果存在，开源软件维护方对所有选型引入的维护版本均须维护。
  说明：开源软件维护方需不断审视社区当前所有软件新版本中的漏洞是否在维护版本存在且受影响，同时开源软件维护方启动对所有受漏洞影响的选型引入的维护版本的漏洞修补。
  案例：例如开源软件维护方A负责维护OpenSSL历史版本1.1.1a/1.1.1b/1.1.1c以及社区最新版本OpenSSL 1.1.1d；开源软件维护方从公司漏洞库感知到OpenSSL 1.1.1d版本存在漏洞CVE-2019-1551，则开源软件维护方须通过官网或NVD披露的漏洞影响版本范围分析漏洞CVE-2019-1551是否也影响OpenSSL 1.1.1a/1.1.1b/1.1.1c，如果也影响，则需要将漏洞影响开源软件的版本刷新到漏洞库，并同时修补OpenSSL 1.1.1a/1.1.1b/1.1.1c版本的漏洞。
* 规则3：开源软件维护方须保证漏洞已按照社区的标准被解决。
  说明：开源软件维护方原则上须按照社区提供的测试方案和测试用例进行构建和验证，确保漏洞已按照社区的标准被解决。
* 规则4：开源软件维护方须自行搭建CI/CD环境，确保至少社区提供的一种构建方案能够编译通过。
  说明：开源软件维护方需不断审视社区当前所有软件新版本中的漏洞是否在维护版本存在且受影响。
* 规则5：满足一定条件，经决策后开源软件维护方可对开源软件或版本停止
  说明：开源软件维护方需不断审视社区当前所有软件新版本中的漏洞是否在维护版本存在且受影响。
  停止维护（EOS）:满足一定条件，经决策后开源软件维护方可停止对某款开源软件或开源软件版本进行维护。
  * 原则上从开源软件EOM时间点开始，3年后停止维护
  * 开源软件已进入衰退期（衰退期定义参考《开源软件选型规范》）
  * 开源软件或版本出现法务license风险等重大安全合规风险
  * 开源软件或软件版本在CleanSource中，但不被任何未EOS产品使用或不再作为主软件使用
  * 开源软件或版本已到官网明确的EOL时间（停止维护公告视EOL公告时间为准）

### 升级版本模式要求

* 规则1：对于社区同时提供新版本和补丁解决漏洞的，原则上由开源软件维护方来确定提供何种修补方案。
  说明：社区升级新版本，开源软件维护方就提供新版本，社区提供补丁，开源软件维护方也提供社区补丁，社区同时提供两种修补方案，开源软件维护方要与社区进行互动，选取社区推荐的修补方案，开源软件维护方评估后确定提供何种修补方案。
  案例：libssh是一款采用升级版本模式维护的软件，为解决libssh 0.7.3以前版本存在的CVE-2016-0739漏洞，社区不仅发布了0.7.4新版本还发布了CVE-2016-0739-libssh-0.5.5.patch、CVE-2016-0739-libssh-0.6.5.patch等补丁文件，开源软件维护方根据社区建议选择新版本0.7.4来修补漏洞。
* 规则2：解决漏洞的新版本须满足选型规范的要求进行引入。
  说明：如果社区提供的解决漏洞的新版本均不满足《开源软件选型规范》，且社区没有提供解决漏洞的补丁，则开源软件维护方可不提供漏洞解决方案，由产品自行消减漏洞风险。
  案例：为解决fastjson 1.2.60拒绝服务安全漏洞，某团队在社区发布修复漏洞的1.2.61 hotfix版本的当天引入公司，经公司TMG评审发现该版本并未经社区测试，该团队也并未评估社区安全修复建议，新版本存在不兼容bug，并导致产品测试环境宕机。
* 规则3：新版本发布后，新/老版本并行，并公示老版本的EOM时间，产品软件版本在选择时根据自己实际情况选择开源软件可配套版本。
  说明：开源软件新版本入仓后，启动老版本EOM公示，EOM时间依据开源维护方的漏洞处理SLO要求确定（一个开源软件新版本解决多个漏洞的场景下，以最高优先级漏洞处理SLO要求确定）。在此期间，已申请的产品，可以在老版本EOM前继续使用老版本，但需要满足漏洞管理要求；产品新申请只能用新软件版本。
  案例：开源软件curl 7.66.0存在一个漏洞需要修复，社区发布新版本7.68.0修复了7.66.0版本的漏洞，开源软件维护方通过选型引入修复漏洞的新版本curl 7.68.0到中心仓后，curl 7.66.0启动EOM公示（公示期依漏洞修复SLO时间确定），同时新版本curl 7.68.0处于可配套状态。

### 补丁回合模式要求

* 规则1：为形成一套面向客户可见的华为开源软件版本管理机制，开源软件维护方须遵循开源软件维护版本命名和漏洞补丁命名规则，规范开源软件维护版本及补丁的名称。
  说明：
   * 开源软件维护版本命名：
     开源软件自身版本命名沿用各自社区命名，维护维护方后续发布的开源软件补丁版本命名如下：开源软件名-社区版本-hX，代号固定为h，X表示数字1~n，可根据需要扩展多位，如openssl-1.1.1a-h1，表示维护维护方发布的Openssl软件1.1.1a版本的第一个补丁版本。
  * 开源软件漏洞补丁命名：
    * 社区发布的CVE补丁，体现CVE名，例如openssl-1.1.1a-CVE-1234.patch；如果涉及一个CVE有多个补丁，可以增加编号，例如openssl-1.1.1a-CVE-1234-001.patch，如果涉及多个CVE，可采用 fix-CVE-multiple等标识，最终在公共配置文件里面描述详细修复内容；
    * 开源软件维护方从新版本回合的CVE补丁，除体现CVE名之外，还需增加backport前缀，例如openssl-1.1.1a-backport-CVE-1234.patch；
    * 社区发布的非CVE补丁，简单描述补丁的功能，例如openssl-1.1.1a-fix-xxxxx.patch；
    * 每个补丁修复一个漏洞，避免出现超大补丁。
* 规则2：为支撑开源软件维护方跨开源软件版本维护，开源软件维护方须遵循维护分支管理规则，对各维护版本进行管理和隔离。
  说明：
   * 维护分支需遵循如下要求：
    * 每一个开源软件版本建立一个分支，存放开源软件社区原始包、公共补丁及公共补丁配置文件
    * 版本分支从master拉出，命名为“软件名_软件版本-stable/upstream”
    * 该分支从公司中心仓开源软件版本路径同步：开源软件社区原始包、公共补丁及公共补丁配置文件，为确保数据一致，建议使用工具实现自动同步
    * 版本分支处于锁定状态，仅产品线开源软件维护方有合入权限
    * 开源软件维护方维护操作限定在中心仓的社区原始包、公共补丁及配置文件范围内，维护方要做好工作环境与各产品维护的补丁或开发的特性的隔离

### 依赖软件维护要求

* 规则：依赖软件的漏洞按照主软件社区提供的漏洞修补方案进行修补，主软件社区未提供漏洞修补方案的，由产品自行消减漏洞风险。
* 主软件社区修补依赖软件漏洞的方式，开源软件维护方可选择任意一种社区方案进行漏洞修补：
  * 如果主软件升级新版本，依赖软件也升级新版本，则升级主软件
  * 如果主软件不升级新版本，但提供补丁修补依赖软件漏洞，则提供社区补丁
* 案例1：开源软件EDKII依赖OpenSSL提供加解密算法能力，社区老版本edk2-stable201908使用的OpenSSL 1.1.1b社区曝出漏洞CVE-2019-1543,CVE-2019-1552和CVE-2019-1563。EDKII社区在2019年11月发布新版本edk2-stable201911，将OpenSSL 1.1.1b升级到OpenSSL 1.1.1d以解决该漏洞，同时开源软件维护方应通过升级EDKII到edk2-stable201911来修补漏洞。
* 案例2：开源软件curl依赖kerberos提供ftp通信能力，curl 7.66.0曝出依赖的Kerberos有高危漏洞CVE-2019-5481。curl社区在2019年9月发布补丁解决该漏洞，但未同时发布新版本，开源软件维护方应通过引入社区补丁来修补漏洞。
